=begin
 This is a machine generated stub using stdlib-doc for <b>module Enumerable</b>
 Ruby sources used:  RUBY-1.8.6-p111
 Created on Fri Dec 07 14:17:01 +0300 2007 by IntelliJ IDEA Ruby Plugin.
=end

#   
#     The <code>Enumerable</code> mixin provides collection classes with
#     several traversal and searching methods, and with the ability to
#     sort. The class must provide a method <code>each</code>, which
#     yields successive members of the collection. If
#     <code>Enumerable#max</code>, <code>#min</code>, or
#     <code>#sort</code> is used, the objects in the collection must also
#     implement a meaningful <code><=></code> operator, as these methods
#     rely on an ordering between members of the collection.
#    
# 
module Enumerable
    public
    #  
    # enum.to_a      =>    array
    # enum.entries   =>    array
    #   
    #     
    #     Returns an array containing the items in <i>enum</i>.
    #        
    #        (1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]
    #        { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [["a", 1], ["b", 2], ["c", 3]]
    #    
    def to_a()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.to_a      =>    array
    # enum.entries   =>    array
    #   
    #     
    #     Returns an array containing the items in <i>enum</i>.
    #        
    #        (1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]
    #        { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [["a", 1], ["b", 2], ["c", 3]]
    #    
    def entries()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.sort                     => array
    # enum.sort {| a, b | block }   => array
    #   
    #     
    #     Returns an array containing the items in <i>enum</i> sorted,
    #     either according to their own <code><=></code> method, or by using
    #     the results of the supplied block. The block should return -1, 0, or
    #     +1 depending on the comparison between <i>a</i> and <i>b</i>. As of
    #     Ruby 1.8, the method <code>Enumerable#sort_by</code> implements a
    #     built-in Schwartzian Transform, useful when key computation or
    #     comparison is expensive..
    #        
    #        %w(rhea kea flea).sort         #=> ["flea", "kea", "rhea"]
    #        (1..10).sort {|a,b| b <=> a}   #=> [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    #    
    # 
    def sort(*several_variants)
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.sort_by {| obj | block }    => array
    #   
    #     
    #     Sorts <i>enum</i> using a set of keys generated by mapping the
    #     values in <i>enum</i> through the given block.
    #        
    #        %w{ apple pear fig }.sort_by {|word| word.length}
    #                     #=> ["fig", "pear", "apple"]
    #        
    #     The current implementation of <code>sort_by</code> generates an
    #     array of tuples containing the original collection element and the
    #     mapped value. This makes <code>sort_by</code> fairly expensive when
    #     the keysets are simple
    #        
    #        require 'benchmark'
    #        include Benchmark
    #        
    #        a = (1..100000).map {rand(100000)}
    #        
    #        bm(10) do |b|
    #          b.report("Sort")    { a.sort }
    #          b.report("Sort by") { a.sort_by {|a| a} }
    #        end
    #        
    #     <em>produces:</em>
    #        
    #        user     system      total        real
    #        Sort        0.180000   0.000000   0.180000 (  0.175469)
    #        Sort by     1.980000   0.040000   2.020000 (  2.013586)
    #        
    #     However, consider the case where comparing the keys is a non-trivial
    #     operation. The following code sorts some files on modification time
    #     using the basic <code>sort</code> method.
    #        
    #        files = Dir["*"]
    #        sorted = files.sort {|a,b| File.new(a).mtime <=> File.new(b).mtime}
    #        sorted   #=> ["mon", "tues", "wed", "thurs"]
    #        
    #     This sort is inefficient: it generates two new <code>File</code>
    #     objects during every comparison. A slightly better technique is to
    #     use the <code>Kernel#test</code> method to generate the modification
    #     times directly.
    #        
    #        files = Dir["*"]
    #        sorted = files.sort { |a,b|
    #          test(?M, a) <=> test(?M, b)
    #        }
    #        sorted   #=> ["mon", "tues", "wed", "thurs"]
    #        
    #     This still generates many unnecessary <code>Time</code> objects. A
    #     more efficient technique is to cache the sort keys (modification
    #     times in this case) before the sort. Perl users often call this
    #     approach a Schwartzian Transform, after Randal Schwartz. We
    #     construct a temporary array, where each element is an array
    #     containing our sort key along with the filename. We sort this array,
    #     and then extract the filename from the result.
    #        
    #        sorted = Dir["*"].collect { |f|
    #           [test(?M, f), f]
    #        }.sort.collect { |f| f[1] }
    #        sorted   #=> ["mon", "tues", "wed", "thurs"]
    #        
    #     This is exactly what <code>sort_by</code> does internally.
    #        
    #        sorted = Dir["*"].sort_by {|f| test(?M, f)}
    #        sorted   #=> ["mon", "tues", "wed", "thurs"]
    #    
    # 
    def sort_by()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.grep(pattern)                   => array
    # enum.grep(pattern) {| obj | block }  => array
    #   
    #     
    #     Returns an array of every element in <i>enum</i> for which
    #     <code>Pattern === element</code>. If the optional <em>block</em> is
    #     supplied, each matching element is passed to it, and the block's
    #     result is stored in the output array.
    #        
    #        (1..100).grep 38..44   #=> [38, 39, 40, 41, 42, 43, 44]
    #        c = IO.constants
    #        c.grep(/SEEK/)         #=> ["SEEK_END", "SEEK_SET", "SEEK_CUR"]
    #        res = c.grep(/SEEK/) {|v| IO.const_get(v) }
    #        res                    #=> [2, 0, 1]
    #        
    #    
    # 
    def grep(*several_variants)
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.detect(ifnone = nil) {| obj | block }  => obj or nil
    # enum.find(ifnone = nil)   {| obj | block }  => obj or nil
    #   
    #     
    #     Passes each entry in <i>enum</i> to <em>block</em>. Returns the
    #     first for which <em>block</em> is not <code>false</code>.  If no
    #     object matches, calls <i>ifnone</i> and returns its result when it
    #     is specified, or returns <code>nil</code>
    #        
    #        (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=> nil
    #        (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=> 35
    #        
    #    
    # 
    def find(ifnone = nil)
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.detect(ifnone = nil) {| obj | block }  => obj or nil
    # enum.find(ifnone = nil)   {| obj | block }  => obj or nil
    #   
    #     
    #     Passes each entry in <i>enum</i> to <em>block</em>. Returns the
    #     first for which <em>block</em> is not <code>false</code>.  If no
    #     object matches, calls <i>ifnone</i> and returns its result when it
    #     is specified, or returns <code>nil</code>
    #        
    #        (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=> nil
    #        (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=> 35
    #        
    #    
    # 
    def detect(ifnone = nil)
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.find_all {| obj | block }  => array
    # enum.select   {| obj | block }  => array
    #   
    #     
    #     Returns an array containing all elements of <i>enum</i> for which
    #     <em>block</em> is not <code>false</code> (see also
    #     <code>Enumerable#reject</code>).
    #        
    #        (1..10).find_all {|i|  i % 3 == 0 }   #=> [3, 6, 9]
    #        
    #    
    # 
    def find_all()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.find_all {| obj | block }  => array
    # enum.select   {| obj | block }  => array
    #   
    #     
    #     Returns an array containing all elements of <i>enum</i> for which
    #     <em>block</em> is not <code>false</code> (see also
    #     <code>Enumerable#reject</code>).
    #        
    #        (1..10).find_all {|i|  i % 3 == 0 }   #=> [3, 6, 9]
    #        
    #    
    # 
    def select()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.reject {| obj | block }  => array
    #   
    #     
    #     Returns an array for all elements of <i>enum</i> for which
    #     <em>block</em> is false (see also <code>Enumerable#find_all</code>).
    #        
    #        (1..10).reject {|i|  i % 3 == 0 }   #=> [1, 2, 4, 5, 7, 8, 10]
    #        
    #    
    # 
    def reject()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.collect {| obj | block }  => array
    # enum.map     {| obj | block }  => array
    #   
    #     
    #     Returns a new array with the results of running <em>block</em> once
    #     for every element in <i>enum</i>.
    #        
    #        (1..4).collect {|i| i*i }   #=> [1, 4, 9, 16]
    #        (1..4).collect { "cat"  }   #=> ["cat", "cat", "cat", "cat"]
    #        
    #    
    # 
    def collect()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.collect {| obj | block }  => array
    # enum.map     {| obj | block }  => array
    #   
    #     
    #     Returns a new array with the results of running <em>block</em> once
    #     for every element in <i>enum</i>.
    #        
    #        (1..4).collect {|i| i*i }   #=> [1, 4, 9, 16]
    #        (1..4).collect { "cat"  }   #=> ["cat", "cat", "cat", "cat"]
    #        
    #    
    # 
    def map()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.inject(initial) {| memo, obj | block }  => obj
    # enum.inject          {| memo, obj | block }  => obj
    #   
    #     
    #     Combines the elements of <i>enum</i> by applying the block to an
    #     accumulator value (<i>memo</i>) and each element in turn. At each
    #     step, <i>memo</i> is set to the value returned by the block. The
    #     first form lets you supply an initial value for <i>memo</i>. The
    #     second form uses the first element of the collection as a the
    #     initial value (and skips that element while iterating).
    #        
    #        # Sum some numbers
    #        (5..10).inject {|sum, n| sum + n }              #=> 45
    #        # Multiply some numbers
    #        (5..10).inject(1) {|product, n| product * n }   #=> 151200
    #        
    #        # find the longest word
    #        longest = %w{ cat sheep bear }.inject do |memo,word|
    #           memo.length > word.length ? memo : word
    #        end
    #        longest                                         #=> "sheep"
    #        
    #        # find the length of the longest word
    #        longest = %w{ cat sheep bear }.inject(0) do |memo,word|
    #           memo >= word.length ? memo : word.length
    #        end
    #        longest                                         #=> 5
    #        
    #    
    # 
    def inject(*several_variants)
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.partition {| obj | block }  => [ true_array, false_array ]
    #   
    #     
    #     Returns two arrays, the first containing the elements of
    #     <i>enum</i> for which the block evaluates to true, the second
    #     containing the rest.
    #        
    #        (1..6).partition {|i| (i&1).zero?}   #=> [[2, 4, 6], [1, 3, 5]]
    #        
    #    
    # 
    def partition()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.all? [{|obj| block } ]   => true or false
    #   
    #     
    #     Passes each element of the collection to the given block. The method
    #     returns <code>true</code> if the block never returns
    #     <code>false</code> or <code>nil</code>. If the block is not given,
    #     Ruby adds an implicit block of <code>{|obj| obj}</code> (that is
    #     <code>all?</code> will return <code>true</code> only if none of the
    #     collection members are <code>false</code> or <code>nil</code>.)
    #        
    #        %w{ ant bear cat}.all? {|word| word.length >= 3}   #=> true
    #        %w{ ant bear cat}.all? {|word| word.length >= 4}   #=> false
    #        [ nil, true, 99 ].all?                             #=> false
    #        
    #    
    # 
    def all?()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.any? [{|obj| block } ]   => true or false
    #   
    #     
    #     Passes each element of the collection to the given block. The method
    #     returns <code>true</code> if the block ever returns a value other
    #     than <code>false</code> or <code>nil</code>. If the block is not
    #     given, Ruby adds an implicit block of <code>{|obj| obj}</code> (that
    #     is <code>any?</code> will return <code>true</code> if at least one
    #     of the collection members is not <code>false</code> or
    #     <code>nil</code>.
    #        
    #        %w{ ant bear cat}.any? {|word| word.length >= 3}   #=> true
    #        %w{ ant bear cat}.any? {|word| word.length >= 4}   #=> true
    #        [ nil, true, 99 ].any?                             #=> true
    #        
    #    
    # 
    def any?()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.min                    => obj
    # enum.min {| a,b | block }   => obj
    #   
    #     
    #     Returns the object in <i>enum</i> with the minimum value. The
    #     first form assumes all objects implement <code>Comparable</code>;
    #     the second uses the block to return <em>a <=> b</em>.
    #        
    #        a = %w(albatross dog horse)
    #        a.min                                  #=> "albatross"
    #        a.min {|a,b| a.length <=> b.length }   #=> "dog"
    #    
    # 
    def min(*several_variants)
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.max                   => obj
    # enum.max {|a,b| block }    => obj
    #   
    #     
    #     Returns the object in _enum_ with the maximum value. The
    #     first form assumes all objects implement <code>Comparable</code>;
    #     the second uses the block to return <em>a <=> b</em>.
    #        
    #        a = %w(albatross dog horse)
    #        a.max                                  #=> "horse"
    #        a.max {|a,b| a.length <=> b.length }   #=> "albatross"
    #      
    # 
    def max(*several_variants)
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.include?(obj)     => true or false
    # enum.member?(obj)      => true or false
    #   
    #     
    #     Returns <code>true</code> if any member of <i>enum</i> equals
    #     <i>obj</i>. Equality is tested using <code>==</code>.
    #        
    #        IO.constants.include? "SEEK_SET"          #=> true
    #        IO.constants.include? "SEEK_NO_FURTHER"   #=> false
    #        
    #    
    # 
    def member?(obj)
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.include?(obj)     => true or false
    # enum.member?(obj)      => true or false
    #   
    #     
    #     Returns <code>true</code> if any member of <i>enum</i> equals
    #     <i>obj</i>. Equality is tested using <code>==</code>.
    #        
    #        IO.constants.include? "SEEK_SET"          #=> true
    #        IO.constants.include? "SEEK_NO_FURTHER"   #=> false
    #        
    #    
    # 
    def include?(obj)
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.each_with_index {|obj, i| block }  -> enum
    #   
    #     
    #     Calls <em>block</em> with two arguments, the item and its index, for
    #     each item in <i>enum</i>.
    #        
    #        hash = Hash.new
    #        %w(cat dog wombat).each_with_index {|item, index|
    #          hash[item] = index
    #        }
    #        hash   #=> {"cat"=>0, "wombat"=>2, "dog"=>1}
    #        
    #    
    # 
    def each_with_index()
        #This is a stub, used for indexing
    end
    public
    #  
    # enum.zip(arg, ...)                   => array
    # enum.zip(arg, ...) {|arr| block }    => nil
    #   
    #     
    #     Converts any arguments to arrays, then merges elements of
    #     <i>enum</i> with corresponding elements from each argument. This
    #     generates a sequence of <code>enum#size</code> <em>n</em>-element
    #     arrays, where <em>n</em> is one more that the count of arguments. If
    #     the size of any argument is less than <code>enum#size</code>,
    #     <code>nil</code> values are supplied. If a block given, it is
    #     invoked for each output array, otherwise an array of arrays is
    #     returned.
    #        
    #        a = [ 4, 5, 6 ]
    #        b = [ 7, 8, 9 ]
    #        
    #        (1..3).zip(a, b)      #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
    #        "cat\ndog".zip([1])   #=> [["cat\n", 1], ["dog", nil]]
    #        (1..3).zip            #=> [[1], [2], [3]]
    #        
    #    
    # 
    def zip(*several_variants)
        #This is a stub, used for indexing
    end
    public
    #  
    # enum_with_index
    #   
    #     
    #     Returns Enumerable::Enumerator.new(self, :each_with_index).
    #   
    #    
    def enum_with_index()
        #This is a stub, used for indexing
    end
    public
    #  
    # e.each_slice(n) {...}
    #   
    #     
    #     Iterates the given block for each slice of <n> elements.
    #   
    #     e.g.:
    #         (1..10).each_slice(3) {|a| p a}
    #         # outputs below
    #         [1, 2, 3]
    #         [4, 5, 6]
    #         [7, 8, 9]
    #         [10]
    #   
    #    
    def each_slice(n)
        #This is a stub, used for indexing
    end
    public
    #  
    # e.enum_slice(n)
    #   
    #     
    #     Returns Enumerable::Enumerator.new(self, :each_slice, n).
    #   
    #    
    def enum_slice(n)
        #This is a stub, used for indexing
    end
    public
    #  
    # each_cons(n) {...}
    #   
    #     
    #     Iterates the given block for each array of consecutive <n>
    #     elements.
    #   
    #     e.g.:
    #         (1..10).each_cons(3) {|a| p a}
    #         # outputs below
    #         [1, 2, 3]
    #         [2, 3, 4]
    #         [3, 4, 5]
    #         [4, 5, 6]
    #         [5, 6, 7]
    #         [6, 7, 8]
    #         [7, 8, 9]
    #         [8, 9, 10]
    #   
    #    
    def each_cons(n)
        #This is a stub, used for indexing
    end
    public
    #  
    # e.enum_cons(n)
    #   
    #     
    #     Returns Enumerable::Enumerator.new(self, :each_cons, n).
    #   
    #    
    def enum_cons(n)
        #This is a stub, used for indexing
    end
    #   
    #    A class which provides a method `each' to be used as an Enumerable
    #    object.
    #    
    class Enumerator < Object
        include Enumerable
        public
        #  
        # Enumerable::Enumerator.new(obj, method = :each, *args)
        #   
        #     
        #     Creates a new Enumerable::Enumerator object, which is to be
        #     used as an Enumerable object using the given object's given
        #     method with the given arguments.
        #   
        #     e.g.:
        #         str = "xyz"
        #   
        #         enum = Enumerable::Enumerator.new(str, :each_byte)
        #         a = enum.map {|b| '%02x' % b } #=> ["78", "79", "7a"]
        #   
        #    
        def self.new(obj, method = :each, *args)
            #This is a stub, used for indexing
        end
        public
        #  
        # enum.each {...}
        #   
        #     
        #     Iterates the given block using the object and the method specified
        #     in the first place.
        #   
        #    
        def each()
            #This is a stub, used for indexing
        end
    end
end
